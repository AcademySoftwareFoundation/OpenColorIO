Python: Config
==============

Examples of Use
^^^^^^^^^^^^^^^
.. code-block:: python

    import PyOpenColorIO as OCIO
    
    # Load an existing configuration from the environment.
    # The resulting configuration is read-only. If $OCIO is set, it will use that.
    # Otherwise it will use an internal default.
    config = OCIO.GetCurrentConfig()
    
    # What color spaces exist?
    colorSpaceNames = [ cs.getName() for cs in config.getColorSpaces() ]
    
    # Given a string, can we parse a color space name from it?
    inputString = 'myname_linear.exr'
    colorSpaceName = config.parseColorSpaceFromString(inputString)
    if colorSpaceName:
        print 'Found color space', colorSpaceName
    else:
        print 'Could not get color space from string', inputString
    
    # What is the name of scene-linear in the configuration?
    colorSpace = config.getColorSpace(OCIO.Constants.ROLE_SCENE_LINEAR)
    if colorSpace:
        print colorSpace.getName()
    else:
        print 'The role of scene-linear is not defined in the configuration'
    
    # For examples of how to actually perform the color transform math,
    # see 'Python: Processor' docs.
    
    # Create a new, empty, editable configuration
    config = OCIO.Config()
    
    # Create a new color space, and add it
    cs = OCIO.ColorSpace(...)
    # (See ColorSpace for details)
    config.addColorSpace(cs)
    
    # For additional examples of config manipulation, see
    # https://github.com/imageworks/OpenColorIO-Configs/blob/master/nuke-default/make.py

Description
^^^^^^^^^^^
A color configuration (:py:class:`Config`) defines all the color spaces to be available at runtime.

(:py:class:`Config`)  is the main object for interacting with this library. 
It encapsulates all the information necessary to use customized
:py:class:`ColorSpaceTransform` and :py:class:`DisplayTransform` operations.

See the :ref:`user-guide` for more information on selecting, creating, 
and working with custom color configurations.

For applications interested in using only one color configuration at
a time (this is the vast majority of apps), their API would
traditionally get the global configuration and use that, as
opposed to creating a new one. This simplifies the use case
for plugins and bindings, as it alleviates the need to pass
around configuration handles.

An example of an application where this would not be
sufficient would be a multi-threaded image proxy server
(daemon) that wants to handle multiple show configurations
concurrently in a single process. This app would need to keep
multiple configurations alive, and manage them appropriately.

Roughly speaking, a novice user should select a default
configuration that most closely approximates the use case
(animation, visual effects, etc.), and set the :envvar:`OCIO`
environment variable to point at the root of that configuration.

.. note::
   Initialization using environment variables is typically preferable
   in a multi-app ecosystem, as it allows all applications to be consistently configured.

.. note::
   Paths to LUTs can be relative. The search paths are defined in :py:class:`Config`.

See :ref:`developers-usageexamples`

.. cpp:class:: Config


Functions
^^^^^^^^^
.. py:function:: Config.CreateFromEnv()
                     
   Create a :py:class:`Config` object using the environment variable.
                     
   :returns: Config object
        

.. py:function:: Config.CreateFromFile(filename)
                     
   Create a :py:class:`Config` object using the information in a file.
           
   :param filename: name of file
   :type filename: string
   :return: Config object
        

Initialization Methods
^^^^^^^^^^^^^^^^^^^^^^
        
.. py:method:: Config.isEditable()
                     
   Returns whether Config is editable.
           
   The configurations returned from
   :py:method:`getCurrentConfig()` are
   not editable, and if you want to edit them you can
   use :py:method:`createEditableCopy()`.
           
   If you attempt to call any of the set functions on
   a noneditable Config, an exception will be thrown.
           
   :return: state of :py:class:`Config`'s editability
   :rtype: bool
        

.. py:method:: Config.createEditableCopy()
                     
   Returns an editable copy of :py:class:`Config`.
           
   :return: editable copy of :py:class:`Config`
   :rtype: Config object
        

.. py:method:: Config.sanityCheck()
                     
   This will throw an exception if :py:class:`Config` is
   malformed. The most common error occurs when
   references are made to colorspaces that do not exist.
        

Resource Methods
^^^^^^^^^^^^^^^^
        
.. py:method:: Config.getDescription()
                     
   Returns the stored description of
   :py:class:`Config`.
           
   :return: stored description of :py:class:`Config`
   :rtype: string
        

.. py:method:: Config.setDescription(desc)
                     
   Sets the description of :py:class:`Config`.
           
   :param desc: description of :py:class:`Config`
   :type desc: string
        

.. py:method:: Config.serialize()
                     
   Returns the string representation of
   :py:class:`Config`
   in YAML text form. This is typically
   stored on disk in a file with the .ocio extension.
           
   :return: :py:class:`Config` in YAML text form
   :rtype: string
        

.. py:method:: Config.getCacheID([, pycontext])
                     
   This will produce a hash of the all colorspace definitions, etc.
           
   All external references, such as files used in FileTransforms, etc.,
   will be incorporated into the cacheID. While the contents of
   the files are not read, the file system is queried for relavent
   information (mtime, inode) so that the ::py:class:`Config`'s cacheID will
   change when the underlying luts are updated.
           
   If a context is not provided, the current Context will be used.
   If a null context is provided, file references will not be taken into
   account (this is essentially a hash of :py:method:`Config.serialize()`).
           
   :param pycontext: optional
   :type pycontext: object
   :return: hash of :py:class:`Config`
   :rtype: string
        

.. py:method:: Config.getSearchPath()
                     
   Returns the search path.
           
   :return: search path
   :rtype: string
        

.. py:method:: Config.setSearchPath(path)
                     
   Sets the search path.
           
   :param path: the search path
   :type path: string
        

.. py:method:: Config.getWorkingDir()
                     
   Returns the working directory.
           
   :return: the working directory
   :rtype path: string
        

.. py:method:: Config.setWorkingDir()
                     
   Sets the working directory.
           
   :param path: the working directory
   :type path: string
        

ColorSpace Methods
^^^^^^^^^^^^^^^^^^
        
.. py:method:: Config.getColorSpaces()
                     
   Returns all the ColorSpaces defined in
   :py:class:`Config`.
           
   :return: ColorSpaces in :py:class:`Config`
   :rtype: tuple
        

.. py:method:: Config.getColorSpace(name)
                     
   Returns the data for the specified color space in
   :py:class:`Config`.
           
   This will return null if the specified name is not found.
           
   :param name: name of color space
   :type name: string
   :return: data for specified color space
   :rtype: pyColorSpace object
        

.. py:method:: Config.addColorSpace(pyColorSpace)
                     
   Add a specified color space to :py:class:`Config`.
           
   :param pyColorSpace: color space
   :type pyColorSpace: object

.. note::
   If another color space is already registered with the same name, this will overwrite it.
        

.. py:method:: Config.clearColorSpaces()
                     
   Clear the color spaces in :py:class:`Config`.
        

.. py:method:: Config.parseColorSpaceFromString(str)
                     
   Parses out the color space from a string.
           
   Given the specified string, gets the longest, right-most color space substring.
   * If strict parsing is enabled, and no color space is found, return an empty string.
   * If strict parsing is disabled, return the default role, if defined.
   * If the default role is not defined, return an empty string.

   :param str: ColorSpace data
   :type str: string
   :return: parsed data
   :rtype: string
        

Roles Methods
^^^^^^^^^^^^^
           
   A role acts as an alias for a ColorSpace.
           
   You can query for the ColorSpace corresponding to a role using
   :py:function:`getColorSpace()`.
        
.. py:method:: Config.setRole(role, csname)
                     
   Set a role's ColorSpace.
           
   Setting the colorSpaceName name to a null string unsets it.

   :param role: role whose ColorSpace will be set
   :type role: string
   :param csname: name of ColorSpace
   :type csname: string
        

Display/View Registration Methods
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        
A display is a virtual or physical display device (e.g., DLP projector or sRGB monitor).
        
A view further specifies what you're trying to see. I.e., display 
set to sRGB and view set to film_avid would be asking to see what 
film_avid on a movie screen would look like on your sRGB
monitor.
        
.. py:method:: Config.getDefaultDisplay()
                     
   Returns the default display set in :py:class:`Config`.

   :return: default display
   :rtype: string 
        

.. py:method:: Config.getDisplays()
                     
   Returns all the displays defined in :py:class:`Config`.

   :return: displays in :py:class:`Config`
   :rtype: list of strings
        

.. py:method:: Config.getDefaultView(display)
                     
   Returns the default view of :py:class:`Config`.

   :param display: default view
   :type display: string
   :return: view
   :rtype: string
        

.. py:method:: Config.getViews(display)
                     
   Returns all the views defined in :py:class:`Config`.

   :param display: views in :py:class:`Config`
   :type display: string
   :return: views in :py:class:`Config`.
   :rtype: list of strings
        

.. py:method:: Config.getDisplayColorSpaceName(display, view)
                     
   Returns the ColorSpace name corresponding to the display and
   view combination in :py:class:`Config`.

   :param display: display
   :type display: string
   :param view: view
   :type view: string
   :return: display color space name
   :rtype: string
        

.. py:method:: Config.getDisplayLooks(display, view)
                     
   Returns the looks corresponding to the display and
   view combination in :py:class:`Config`.

   :param display: display
   :type display: string
   :param view: view
   :type view: string
   :return: looks
   :rtype: string
        

.. py:method:: Config.addDisplay(display, view, colorSpaceName[, looks])
                     
   NEEDS WORK

   :param display:
   :type display: string
   :param view: 
   :type view: string
   :param colorSpaceName: 
   :type colorSpaceName: string
   :param looks: optional
   :type looks: string
        

.. py:method:: Config.clearDisplays()
                     
           
        

.. py:method:: Config.setActiveDisplays()
                     
   Sets the active displays in :py:class:`Config`.
           
   :param displays: active displays
   :type displays: string
        

.. py:method:: Config.getActiveDisplays()
                     
   Returns the active displays in :py:class:`Config`.
           
   :return: active displays
   :rtype: string
        

.. py:method:: Config.setActiveViews()
                     
   Sets the active views in :py:class:`Config`.
           
   :param displays: active views
   :type displays: string
        

.. py:method:: Config.getActiveViews()
                     
   Returns the active views in :py:class:`Config`.
           
   :return: active views
   :rtype: string
        

Luma Methods
^^^^^^^^^^^^
        
Manage the default coefficients for computing luma.
        
.. note::
   There is no one-size-fits-all set of luma coefficients. The values are typically
   different for each ColorSpace, and the application of them may be nonsensical 
   depending on the intensity coding. Thus, the right answer is to make these functions
   on the :py:class:`Config` class. However, it's often useful to have a Config-wide
   default, so here it is. We will add the ColorSpace specific luma call when another
   client is interested in using it.
        
.. py:method:: Config.setDefaultLumaCoefs()
                     
   Sets the default luma coefficients in :py:class:`Config`.
           
   :param pyCoef: luma coefficients
   :type pyCoef: object
        

.. py:method:: Config.getDefaultLumaCoefs()
                     
   Returns the default luma coefficients in :py:class:`Config`.
           
   :return: luma coefficients
   :rtype: list of floats
        

Look Methods
^^^^^^^^^^^^
        
Manage per-shot look settings.
        
Looks is a comma- or colon-delimited list of lookNames, where optional '+' and '-' prefixes
denote forward and inverse look specifications, respectively. A forward look is assumed in
the absence of a prefix.

.. py:method:: Config.getLook()
                     
   Returns the information of a specified look in :py:class:`Config`.
           
   :param str: look
   :type str: string
   :return: specified look
   :rtype: look object
        

.. py:method:: Config.getLooks()
                     
   Returns a list of all the looks defined in :py:class:`Config`.
           
   :return: looks
   :rtype: tuple of look objects
        

.. py:method:: Config.addLook()
                     
   Adds a look to :py:class:`Config`.
           
   :param pylook: look
   :type pylook: look object
        

.. py:method:: Config.clearLook()
                     
   Clear look in :py:class:`Config`.
        

Processor Methods
^^^^^^^^^^^^^^^^^
        
Used to convert from inputColorSpace to outputColorSpace.
        
.. py:method:: Config.getProcessor(arg1[, arg2[, direction[, context]])
           
   Returns a processor for a specified transform.
           
   Although this is not often needed, it allows for the reuse of atomic 
   OCIO functionality, such as applying an individual LUT file.
           
   There are two canonical ways of creating a
   :py:class:`Processor`:
           
   #. Pass a transform into arg1, in which case arg2 will be ignored. 
   #. Set arg1 as the source and arg2 as the destination. These can be ColorSpace names, objects, or roles.
           
   Both arguments, ``direction`` (of transform) and ``context``, are
   optional and respected for both methods of :py:class:`Processor`
   creation.
           
   This will fail if either the source or destination color space is null.
           
   See Python: Processor for more details.
           
   .. note::
     This may provide higher fidelity than anticipated due to internal optimizations. 
     For example, if inputColorSpace and outputColorSpace are members of the same family,
     no conversion will be applied, even though, strictly speaking, quantization should be added.
           
     If you wish to test these calls for quantization characteristics, apply in two steps; 
     the image must contain RGB triples (though arbitrary numbers of additional channels 
     can be optionally supported using the pixelStrideBytes arg). ???
        
   :param arg1: 
   :type arg1: object
   :param arg2: ignored if arg1 is a transform
   :type arg2: object
   :param direction: optional
   :type direction: string
   :param context: optional
   :type context: object
         
        

