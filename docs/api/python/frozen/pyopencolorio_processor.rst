..
  SPDX-License-Identifier: CC-BY-4.0
  Copyright Contributors to the OpenColorIO Project.
  Do not edit! This file was automatically generated by share/docs/frozendoc.py.

.. py:class:: Processor
   :module: PyOpenColorIO

   The *:ref:`Processor`* represents a specific color transformation which is the result of :ref:`Config::getProcessor`.


   .. py:method:: Processor.__init__(*args, **kwargs)
      :module: PyOpenColorIO


   .. py:method:: Processor.createGroupTransform(self: PyOpenColorIO.Processor) -> PyOpenColorIO.GroupTransform
      :module: PyOpenColorIO

      Return a :ref:`GroupTransform` that contains a copy of the transforms that comprise the processor. (Changes to it will not modify the original processor.) Note that the :ref:`GroupTransform::write` method may be used to serialize a :ref:`Processor`. Serializing to CTF format is a useful technique for debugging :ref:`Processor` contents.


   .. py:method:: Processor.getCacheID(self: PyOpenColorIO.Processor) -> str
      :module: PyOpenColorIO


   .. py:method:: Processor.getDefaultCPUProcessor(self: PyOpenColorIO.Processor) -> PyOpenColorIO.CPUProcessor
      :module: PyOpenColorIO

      Get an optimized :ref:`CPUProcessor` instance.

      .. note::
         This may provide higher fidelity than anticipated due to internal optimizations. For example, if the inputColorSpace and the outputColorSpace are members of the same equalitygroup, no conversion will be applied, even though strictly speaking quantization should be added.

      .. note::
         The typical use case to apply color processing to an image is:

      .. code-block:: cpp

          OCIO::ConstConfigRcPtr config = OCIO::GetCurrentConfig();

          OCIO::ConstProcessorRcPtr processor
              = config->getProcessor(colorSpace1, colorSpace2);

          OCIO::ConstCPUProcessorRcPtr cpuProcessor
              = processor->getDefaultCPUProcessor();

          OCIO::PackedImageDesc img(imgDataPtr, imgWidth, imgHeight, imgChannels);
          cpuProcessor->apply(img);


   .. py:method:: Processor.getDefaultGPUProcessor(self: PyOpenColorIO.Processor) -> PyOpenColorIO.GPUProcessor
      :module: PyOpenColorIO

      Get an optimized :ref:`GPUProcessor` instance.


   .. py:method:: Processor.getDynamicProperty(self: PyOpenColorIO.Processor, type: PyOpenColorIO.DynamicPropertyType) -> PyOpenColorIO.DynamicProperty
      :module: PyOpenColorIO

      The returned pointer may be used to set the default value of any dynamic properties of the requested type. Throws if the requested property is not found. Note that if the processor contains several ops that support the requested property, only one can be dynamic and only this one will be controlled.

      .. note::
         The dynamic properties are a convenient way to change on-the-fly values without generating again and again a CPU or GPU processor instance. Color transformations can contain dynamic properties from a :ref:`ExposureContrastTransform` for example. So, :ref:`Processor`, :ref:`CPUProcessor` and :ref:`GpuShaderCreator` all have ways to manage dynamic properties. However, the transform dynamic properties are decoupled between the types of processor instances so that the same :ref:`Processor` can generate several independent CPU and/or GPU processor instances i.e. changing the value of the exposure dynamic property from a CPU processor instance does not affect the corresponding GPU processor instance. :ref:`Processor` creation will log a warning if there are more than one property of a given type. There may be more than one property of a given type, but only one will respond to parameter updates, the others will use their original parameter values.


   .. py:method:: Processor.getFormatMetadata(self: PyOpenColorIO.Processor) -> PyOpenColorIO.FormatMetadata
      :module: PyOpenColorIO

      Get a :ref:`FormatMetadata` containing the top level metadata for the processor. For a processor from a CLF file, this corresponds to the ProcessList metadata.


   .. py:method:: Processor.getOptimizedCPUProcessor(*args, **kwargs)
      :module: PyOpenColorIO

      Overloaded function.

      1. getOptimizedCPUProcessor(self: PyOpenColorIO.Processor, oFlags: PyOpenColorIO.OptimizationFlags) -> PyOpenColorIO.CPUProcessor

      2. getOptimizedCPUProcessor(self: PyOpenColorIO.Processor, inBitDepth: PyOpenColorIO.BitDepth, outBitDepth: PyOpenColorIO.BitDepth, oFlags: PyOpenColorIO.OptimizationFlags) -> PyOpenColorIO.CPUProcessor


   .. py:method:: Processor.getOptimizedGPUProcessor(self: PyOpenColorIO.Processor, oFlags: PyOpenColorIO.OptimizationFlags) -> PyOpenColorIO.GPUProcessor
      :module: PyOpenColorIO


   .. py:method:: Processor.getOptimizedProcessor(*args, **kwargs)
      :module: PyOpenColorIO

      Overloaded function.

      1. getOptimizedProcessor(self: PyOpenColorIO.Processor, oFlags: PyOpenColorIO.OptimizationFlags) -> PyOpenColorIO.Processor

      Run the optimizer on a :ref:`Processor` to create a new :ref:`Processor`. It is usually not necessary to call this since getting a :ref:`CPUProcessor` or :ref:`GPUProcessor` will also optimize. However if you need both, calling this method first makes getting a CPU and GPU :ref:`Processor` faster since the optimization is effectively only done once.

      2. getOptimizedProcessor(self: PyOpenColorIO.Processor, inBitDepth: PyOpenColorIO.BitDepth, outBitDepth: PyOpenColorIO.BitDepth, oFlags: PyOpenColorIO.OptimizationFlags) -> PyOpenColorIO.Processor

      Run the optimizer on a :ref:`Processor` to create a new :ref:`Processor`. It is usually not necessary to call this since getting a :ref:`CPUProcessor` or :ref:`GPUProcessor` will also optimize. However if you need both, calling this method first makes getting a CPU and GPU :ref:`Processor` faster since the optimization is effectively only done once.


   .. py:method:: Processor.getProcessorMetadata(self: PyOpenColorIO.Processor) -> PyOpenColorIO.ProcessorMetadata
      :module: PyOpenColorIO

      The :ref:`ProcessorMetadata` contains technical information such as the number of files and looks used in the processor.


   .. py:method:: Processor.getTransformFormatMetadata(self: PyOpenColorIO.Processor) -> PyOpenColorIO.Processor.TransformFormatMetadataIterator
      :module: PyOpenColorIO


   .. py:method:: Processor.hasChannelCrosstalk(self: PyOpenColorIO.Processor) -> bool
      :module: PyOpenColorIO

      True if the image transformation is non-separable. For example, if a change in red may also cause a change in green or blue.


   .. py:method:: Processor.hasDynamicProperty(self: PyOpenColorIO.Processor, type: PyOpenColorIO.DynamicPropertyType) -> bool
      :module: PyOpenColorIO

      True if at least one dynamic property of that type exists.


   .. py:method:: Processor.isDynamic(self: PyOpenColorIO.Processor) -> bool
      :module: PyOpenColorIO

      True if at least one dynamic property of any type exists and is dynamic.


   .. py:method:: Processor.isNoOp(self: PyOpenColorIO.Processor) -> bool
      :module: PyOpenColorIO


.. py:class:: TransformFormatMetadataIterator
   :module: PyOpenColorIO.Processor


   .. py:method:: TransformFormatMetadataIterator.__getitem__(self: PyOpenColorIO.Processor.TransformFormatMetadataIterator, arg0: int) -> PyOpenColorIO.FormatMetadata
      :module: PyOpenColorIO.Processor


   .. py:method:: TransformFormatMetadataIterator.__iter__(self: PyOpenColorIO.Processor.TransformFormatMetadataIterator) -> PyOpenColorIO.Processor.TransformFormatMetadataIterator
      :module: PyOpenColorIO.Processor


   .. py:method:: TransformFormatMetadataIterator.__len__(self: PyOpenColorIO.Processor.TransformFormatMetadataIterator) -> int
      :module: PyOpenColorIO.Processor


   .. py:method:: TransformFormatMetadataIterator.__next__(self: PyOpenColorIO.Processor.TransformFormatMetadataIterator) -> PyOpenColorIO.FormatMetadata
      :module: PyOpenColorIO.Processor

