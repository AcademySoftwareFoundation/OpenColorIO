..
  SPDX-License-Identifier: CC-BY-4.0
  Copyright Contributors to the OpenColorIO Project.
  Do not edit! This file was automatically generated by share/docs/frozendoc.py.

.. py:class:: Processor
   :module: PyOpenColorIO

   The *:ref:`Processor`* represents a specific color transformation which is the result of :cpp:func:`Config::getProcessor`.


   .. py:method:: Processor.__init__(*args, **kwargs)
      :module: PyOpenColorIO

      Initialize self.  See help(type(self)) for accurate signature.


   .. py:method:: Processor.createGroupTransform(self: PyOpenColorIO.Processor) -> PyOpenColorIO.GroupTransform
      :module: PyOpenColorIO

      Return a :ref:`GroupTransform` that contains a copy of the transforms that comprise the processor. (Changes to it will not modify the original processor.)


   .. py:method:: Processor.getCacheID(self: PyOpenColorIO.Processor) -> str
      :module: PyOpenColorIO


   .. py:method:: Processor.getDefaultCPUProcessor(self: PyOpenColorIO.Processor) -> OpenColorIO_v2_0beta1::CPUProcessor
      :module: PyOpenColorIO

      Get an optimized :cpp:class:`:ref:`CPUProcessor`` instance.

      .. note::
         This may provide higher fidelity than anticipated due to internal optimizations. For example, if the inputColorSpace and the outputColorSpace are members of the same family, no conversion will be applied, even though strictly speaking quantization should be added.

      .. note::
         The typical use case to apply color processing to an image is:

      .. code-block:: cpp

          OCIO::ConstConfigRcPtr config = OCIO::GetCurrentConfig();

          OCIO::ConstProcessorRcPtr processor
              = config->getProcessor(colorSpace1, colorSpace2);

          OCIO::ConstCPUProcessorRcPtr cpuProcessor
              = processor->getDefaultCPUProcessor();

          OCIO::PackedImageDesc img(imgDataPtr, imgWidth, imgHeight, imgChannels);
          cpuProcessor->apply(img);


   .. py:method:: Processor.getDefaultGPUProcessor(self: PyOpenColorIO.Processor) -> OpenColorIO_v2_0beta1::GPUProcessor
      :module: PyOpenColorIO

      Get an optimized :ref:`GPUProcessor` instance.


   .. py:method:: Processor.getDynamicProperty(self: PyOpenColorIO.Processor, type: PyOpenColorIO.DynamicPropertyType) -> OpenColorIO_v2_0beta1::DynamicProperty
      :module: PyOpenColorIO

      The returned pointer may be used to set the default value of any dynamic properties of the requested type. Throws if the requested property is not found. Note that if the processor contains several ops that support the requested property, only ones for which dynamic has been enabled will be controlled.

      .. note::
         The dynamic properties are a convenient way to change on-the-fly values without generating again and again a CPU or GPU processor instance. Color transformations can contain dynamic properties from a :cpp:class:`:ref:`ExposureContrastTransform`` for example. So, :cpp:class:`:ref:`Processor``, :cpp:class:`:ref:`CPUProcessor`` and :cpp:class:`:ref:`GpuShaderCreator`` all have ways to manage dynamic properties. However, the transform dynamic properties are decoupled between the types of processor instances so that the same :cpp:class:`:ref:`Processor`` can generate several independent CPU and/or GPU processor instances i.e. changing the value of the exposure dynamic property from a CPU processor instance does not affect the corresponding GPU processor instance.


   .. py:method:: Processor.getFormatMetadata(self: PyOpenColorIO.Processor) -> PyOpenColorIO.FormatMetadata
      :module: PyOpenColorIO

      Get a :ref:`FormatMetadata` containing the top level metadata for the processor. For a processor from a CLF file, this corresponds to the ProcessList metadata.


   .. py:method:: Processor.getOptimizedCPUProcessor(*args, **kwargs)
      :module: PyOpenColorIO

      Overloaded function.

      1. getOptimizedCPUProcessor(self: PyOpenColorIO.Processor, oFlags: PyOpenColorIO.OptimizationFlags) -> OpenColorIO_v2_0beta1::CPUProcessor

      2. getOptimizedCPUProcessor(self: PyOpenColorIO.Processor, inBitDepth: PyOpenColorIO.BitDepth, outBitDepth: PyOpenColorIO.BitDepth, oFlags: PyOpenColorIO.OptimizationFlags) -> OpenColorIO_v2_0beta1::CPUProcessor


   .. py:method:: Processor.getOptimizedGPUProcessor(self: PyOpenColorIO.Processor, oFlags: PyOpenColorIO.OptimizationFlags) -> OpenColorIO_v2_0beta1::GPUProcessor
      :module: PyOpenColorIO


   .. py:method:: Processor.getOptimizedProcessor(*args, **kwargs)
      :module: PyOpenColorIO

      Overloaded function.

      1. getOptimizedProcessor(self: PyOpenColorIO.Processor, oFlags: PyOpenColorIO.OptimizationFlags) -> PyOpenColorIO.Processor

      Run the optimizer on a :ref:`Processor` to create a new :cpp:class:`:ref:`Processor``. It is usually not necessary to call this since getting a :ref:`CPUProcessor` or :ref:`GPUProcessor` will also optimize. However if you need both, calling this method first makes getting a CPU and GPU :ref:`Processor` faster since the optimization is effectively only done once.

      2. getOptimizedProcessor(self: PyOpenColorIO.Processor, inBitDepth: PyOpenColorIO.BitDepth, outBitDepth: PyOpenColorIO.BitDepth, oFlags: PyOpenColorIO.OptimizationFlags) -> PyOpenColorIO.Processor

      Run the optimizer on a :ref:`Processor` to create a new :cpp:class:`:ref:`Processor``. It is usually not necessary to call this since getting a :ref:`CPUProcessor` or :ref:`GPUProcessor` will also optimize. However if you need both, calling this method first makes getting a CPU and GPU :ref:`Processor` faster since the optimization is effectively only done once.


   .. py:method:: Processor.getProcessorMetadata(self: PyOpenColorIO.Processor) -> OpenColorIO_v2_0beta1::ProcessorMetadata
      :module: PyOpenColorIO

      The :ref:`ProcessorMetadata` contains technical information such as the number of files and looks used in the processor.


   .. py:method:: Processor.getTransformFormatMetadata(self: PyOpenColorIO.Processor) -> PyOpenColorIO.Processor.TransformFormatMetadataIterator
      :module: PyOpenColorIO


   .. py:method:: Processor.getWriteFormats() -> PyOpenColorIO.Processor.WriteFormatIterator
      :module: PyOpenColorIO
      :staticmethod:


   .. py:method:: Processor.hasChannelCrosstalk(self: PyOpenColorIO.Processor) -> bool
      :module: PyOpenColorIO

      True if the image transformation is non-separable. For example, if a change in red may also cause a change in green or blue.


   .. py:method:: Processor.hasDynamicProperty(*args, **kwargs)
      :module: PyOpenColorIO

      Overloaded function.

      1. hasDynamicProperty(self: PyOpenColorIO.Processor, type: PyOpenColorIO.DynamicPropertyType) -> bool

      True if at least one dynamic property of that type exists.

      2. hasDynamicProperty(self: PyOpenColorIO.Processor) -> bool

      True if at least one dynamic property of that type exists.


   .. py:method:: Processor.isNoOp(self: PyOpenColorIO.Processor) -> bool
      :module: PyOpenColorIO


   .. py:method:: Processor.write(*args, **kwargs)
      :module: PyOpenColorIO

      Overloaded function.

      1. write(self: PyOpenColorIO.Processor, formatName: str, fileName: str) -> None

      2. write(self: PyOpenColorIO.Processor, formatName: str) -> str

      Write the transforms comprising the processor to the stream. Writing (as opposed to Baking) is a lossless process. An exception is thrown if the processor cannot be losslessly written to the specified file format.


.. py:class:: TransformFormatMetadataIterator
   :module: PyOpenColorIO.Processor


   .. py:method:: TransformFormatMetadataIterator.__getitem__(self: PyOpenColorIO.Processor.TransformFormatMetadataIterator, arg0: int) -> PyOpenColorIO.FormatMetadata
      :module: PyOpenColorIO.Processor


   .. py:method:: TransformFormatMetadataIterator.__iter__(self: PyOpenColorIO.Processor.TransformFormatMetadataIterator) -> PyOpenColorIO.Processor.TransformFormatMetadataIterator
      :module: PyOpenColorIO.Processor


   .. py:method:: TransformFormatMetadataIterator.__len__(self: PyOpenColorIO.Processor.TransformFormatMetadataIterator) -> int
      :module: PyOpenColorIO.Processor


   .. py:method:: TransformFormatMetadataIterator.__next__(self: PyOpenColorIO.Processor.TransformFormatMetadataIterator) -> PyOpenColorIO.FormatMetadata
      :module: PyOpenColorIO.Processor


.. py:class:: WriteFormatIterator
   :module: PyOpenColorIO.Processor


   .. py:method:: WriteFormatIterator.__getitem__(self: PyOpenColorIO.Processor.WriteFormatIterator, arg0: int) -> tuple
      :module: PyOpenColorIO.Processor


   .. py:method:: WriteFormatIterator.__iter__(self: PyOpenColorIO.Processor.WriteFormatIterator) -> PyOpenColorIO.Processor.WriteFormatIterator
      :module: PyOpenColorIO.Processor


   .. py:method:: WriteFormatIterator.__len__(self: PyOpenColorIO.Processor.WriteFormatIterator) -> int
      :module: PyOpenColorIO.Processor


   .. py:method:: WriteFormatIterator.__next__(self: PyOpenColorIO.Processor.WriteFormatIterator) -> tuple
      :module: PyOpenColorIO.Processor

