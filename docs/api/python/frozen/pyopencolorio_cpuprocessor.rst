..
  SPDX-License-Identifier: CC-BY-4.0
  Copyright Contributors to the OpenColorIO Project.
  Do not edit! This file was automatically generated by share/docs/frozendoc.py.

.. py:class:: CPUProcessor
   :module: PyOpenColorIO


   .. py:method:: CPUProcessor.__init__(*args, **kwargs)
      :module: PyOpenColorIO

      Initialize self.  See help(type(self)) for accurate signature.


   .. py:method:: CPUProcessor.apply(*args, **kwargs)
      :module: PyOpenColorIO

      Overloaded function.

      1. apply(self: PyOpenColorIO.CPUProcessor, imgDesc: OpenColorIO_v2_0beta1::PyImageDesc) -> None

      Apply to an image with any kind of channel ordering while respecting the input and output bit-depths.

      2. apply(self: PyOpenColorIO.CPUProcessor, srcImgDesc: OpenColorIO_v2_0beta1::PyImageDesc, dstImgDesc: OpenColorIO_v2_0beta1::PyImageDesc) -> None


   .. py:method:: CPUProcessor.applyRGB(*args, **kwargs)
      :module: PyOpenColorIO

      Overloaded function.

      1. applyRGB(self: PyOpenColorIO.CPUProcessor, pixel: buffer) -> buffer

      Apply to a single pixel respecting that the input and output bit-depths be 32-bit float and the image buffer be packed RGB/RGBA.

      .. note::
         This is not as efficient as applying to an entire image at once. If you are processing multiple pixels, and have the flexibility, use the above function instead.

      2. applyRGB(self: PyOpenColorIO.CPUProcessor, pixel: List[float]) -> List[float]

      Apply to a single pixel respecting that the input and output bit-depths be 32-bit float and the image buffer be packed RGB/RGBA.

      .. note::
         This is not as efficient as applying to an entire image at once. If you are processing multiple pixels, and have the flexibility, use the above function instead.


   .. py:method:: CPUProcessor.applyRGBA(*args, **kwargs)
      :module: PyOpenColorIO

      Overloaded function.

      1. applyRGBA(self: PyOpenColorIO.CPUProcessor, pixel: buffer) -> buffer

      2. applyRGBA(self: PyOpenColorIO.CPUProcessor, pixel: List[float]) -> List[float]


   .. py:method:: CPUProcessor.getCacheID(self: PyOpenColorIO.CPUProcessor) -> str
      :module: PyOpenColorIO


   .. py:method:: CPUProcessor.getDynamicProperty(self: PyOpenColorIO.CPUProcessor, type: PyOpenColorIO.DynamicPropertyType) -> PyOpenColorIO.DynamicProperty
      :module: PyOpenColorIO


   .. py:method:: CPUProcessor.getInputBitDepth(self: PyOpenColorIO.CPUProcessor) -> PyOpenColorIO.BitDepth
      :module: PyOpenColorIO

      Bit-depth of the input pixel buffer.


   .. py:method:: CPUProcessor.getOutputBitDepth(self: PyOpenColorIO.CPUProcessor) -> PyOpenColorIO.BitDepth
      :module: PyOpenColorIO

      Bit-depth of the output pixel buffer.


   .. py:method:: CPUProcessor.hasChannelCrosstalk(self: PyOpenColorIO.CPUProcessor) -> bool
      :module: PyOpenColorIO


   .. py:method:: CPUProcessor.isIdentity(self: PyOpenColorIO.CPUProcessor) -> bool
      :module: PyOpenColorIO

      Equivalent to isNoOp from the underlying :ref:`Processor`, i.e., it ignores in/out bit-depth differences.


   .. py:method:: CPUProcessor.isNoOp(self: PyOpenColorIO.CPUProcessor) -> bool
      :module: PyOpenColorIO

      The in and out bit-depths must be equal for isNoOp to be true.

