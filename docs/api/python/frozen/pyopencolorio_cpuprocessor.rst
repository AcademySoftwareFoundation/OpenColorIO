..
  SPDX-License-Identifier: CC-BY-4.0
  Copyright Contributors to the OpenColorIO Project.
  Do not edit! This file was automatically generated by share/docs/frozendoc.py.

.. py:class:: CPUProcessor
   :module: PyOpenColorIO


   .. py:method:: CPUProcessor.__init__(*args, **kwargs)
      :module: PyOpenColorIO


   .. py:method:: CPUProcessor.apply(*args, **kwargs)
      :module: PyOpenColorIO

      Overloaded function.

      1. apply(self: PyOpenColorIO.CPUProcessor, imgDesc: PyOpenColorIO.ImageDesc) -> None


      Apply to an image with any kind of channel ordering while respecting
      the input and output bit-depths. Image values are modified in place.

      .. note::
          The GIL is released during processing, freeing up Python to execute
          other threads concurrently.

      .. note::
          For large images, ``applyRGB`` or ``applyRGBA`` are preferred for
          processing a NumPy array. The Python ``ImageDesc`` implementation
          requires copying all values (once) in order to own the underlying
          pointer. The dedicated packed ``apply*`` methods utilize
          ``ImageDesc`` on the C++ side so avoid the copy.



      2. apply(self: PyOpenColorIO.CPUProcessor, srcImgDesc: PyOpenColorIO.ImageDesc, dstImgDesc: PyOpenColorIO.ImageDesc) -> None


      Apply to an image with any kind of channel ordering while respecting
      the input and output bit-depths. Modified srcImgDesc image values are
      written to the dstImgDesc image, leaving srcImgDesc unchanged.

      .. note::
          The GIL is released during processing, freeing up Python to execute
          other threads concurrently.

      .. note::
          For large images, ``applyRGB`` or ``applyRGBA`` are preferred for
          processing a NumPy array. The Python ``ImageDesc`` implementation
          requires copying all values (once) in order to own the underlying
          pointer. The dedicated packed ``apply*`` methods utilize
          ``ImageDesc`` on the C++ side so avoid the copy.


   .. py:method:: CPUProcessor.applyRGB(*args, **kwargs)
      :module: PyOpenColorIO

      Overloaded function.

      1. applyRGB(self: PyOpenColorIO.CPUProcessor, data: buffer) -> None


      Apply to a packed RGB array adhering to the Python buffer protocol.
      This will typically be a NumPy array. Input and output bit-depths are
      respected but must match. Any array size or shape is supported as long
      as the flattened array size is divisible by 3. Array values are
      modified in place.

      .. note::
          This differs from the C++ implementation which only applies to a
          single pixel. This method uses a ``PackedImageDesc`` under the
          hood to apply to an entire image at once. The GIL is released
          during processing, freeing up Python to execute other threads
          concurrently.



      2. applyRGB(self: PyOpenColorIO.CPUProcessor, data: List[float]) -> List[float]


      Apply to a packed RGB list of float values. Any size is supported as
      long as the list length is divisible by 3. A new list with processed
      float values is returned, leaving the input list unchanged.

      .. note::
          This differs from the C++ implementation which only applies to a
          single pixel. This method uses a ``PackedImageDesc`` under the
          hood to apply to an entire image at once. The GIL is released
          during processing, freeing up Python to execute other threads
          concurrently.

      .. note::
          For large images, a NumPy array should be preferred over a list.
          List values are copied on input and output, where an array is
          modified in place.


   .. py:method:: CPUProcessor.applyRGBA(*args, **kwargs)
      :module: PyOpenColorIO

      Overloaded function.

      1. applyRGBA(self: PyOpenColorIO.CPUProcessor, data: buffer) -> None


      Apply to a packed RGBA array adhering to the Python buffer protocol.
      This will typically be a NumPy array. Input and output bit-depths are
      respected but must match. Any array size or shape is supported as long
      as the flattened array size is divisible by 4. Array values are
      modified in place.

      .. note::
          This differs from the C++ implementation which only applies to a
          single pixel. This method uses a ``PackedImageDesc`` under the
          hood to apply to an entire image at once. The GIL is released
          during processing, freeing up Python to execute other threads
          concurrently.



      2. applyRGBA(self: PyOpenColorIO.CPUProcessor, data: List[float]) -> List[float]


      Apply to a packed RGBA list of float values. Any size is supported as
      long as the list length is divisible by 4. A new list with processed
      float values is returned, leaving the input list unchanged.

      .. note::
          This differs from the C++ implementation which only applies to a
          single pixel. This method uses a ``PackedImageDesc`` under the
          hood to apply to an entire image at once. The GIL is released
          during processing, freeing up Python to execute other threads
          concurrently.

      .. note::
          For large images, a NumPy array should be preferred over a list.
          List values are copied on input and output, where an array is
          modified in place.


   .. py:method:: CPUProcessor.getCacheID(self: PyOpenColorIO.CPUProcessor) -> str
      :module: PyOpenColorIO


   .. py:method:: CPUProcessor.getDynamicProperty(self: PyOpenColorIO.CPUProcessor, type: PyOpenColorIO.DynamicPropertyType) -> PyOpenColorIO.DynamicProperty
      :module: PyOpenColorIO

      The returned pointer may be used to set the value of any dynamic properties of the requested type. Throws if the requested property is not found. Note that if the processor contains several ops that support the requested property, only one can be dynamic.

      .. note::
         The dynamic properties in this object are decoupled from the ones in the :ref:`Processor` it was generated from. For each dynamic property in the :ref:`Processor`, there is one in the CPU processor.


   .. py:method:: CPUProcessor.getInputBitDepth(self: PyOpenColorIO.CPUProcessor) -> PyOpenColorIO.BitDepth
      :module: PyOpenColorIO

      Bit-depth of the input pixel buffer.


   .. py:method:: CPUProcessor.getOutputBitDepth(self: PyOpenColorIO.CPUProcessor) -> PyOpenColorIO.BitDepth
      :module: PyOpenColorIO

      Bit-depth of the output pixel buffer.


   .. py:method:: CPUProcessor.hasChannelCrosstalk(self: PyOpenColorIO.CPUProcessor) -> bool
      :module: PyOpenColorIO


   .. py:method:: CPUProcessor.isIdentity(self: PyOpenColorIO.CPUProcessor) -> bool
      :module: PyOpenColorIO

      Equivalent to isNoOp from the underlying :ref:`Processor`, i.e., it ignores in/out bit-depth differences.


   .. py:method:: CPUProcessor.isNoOp(self: PyOpenColorIO.CPUProcessor) -> bool
      :module: PyOpenColorIO

      The in and out bit-depths must be equal for isNoOp to be true.

